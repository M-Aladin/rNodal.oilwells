---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->


```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-"
)
```

# rNodal.oilwells

The goal of `rNodal.oilwells` is to start processing well raw data and transforming it into tidy data.

## Installation

You can install rNodal.oilwells from github with:

```{r gh-installation, eval = FALSE}
# install.packages("devtools")
devtools::install_github("f0nzie/rNodal.oilwells")
```

Soon to be presented to CRAN.

# Data Science for Petroleum Engineering - Part 5: "Transforming Excel well raw data into datasets.

One of the big challenges of this new era of data science. machine learning and artificial intelligence is getting unhooked from the habit of working with spreadsheets. They have been around for 30+ years and were awesome. But spreadsheets - or worksheets - do not scale well with massive amounts of data; or continuous streams of data; or other characteristics that are key for taking good and sound decisions such as **reproducibility**. Besides, spreadsheets have not kept with the times so we have seen the plotting capabilities getting very much behind of other software.

*Plots are the most expressive way that you can show your data and analysis.*

This time we will start with some well raw data. This data is part of the input data that we require to create well models for nodal analysis, IPR/VLP calibration with well test data, troubleshooting, plan a stimulation job, or reviewing the well technical potential. In my case, this data was input for Petroleum Experts's **Prosper**. But the same could have been used with Schlumberger's **Pipesim**, or any other.


Again, we will use R for these tasks. What we will do is:

* Read the Excel data into R
* Perform a basic statistics on the raw data
* Find problems with data: data missing or improperly entered
* Deal with missing data and correct typing issues
* Convert the raw data to tidy data before analysis and plotting
* Save the tidy data
* See what story the data is trying to tell us
* Present our discoveries

## Setting the stage

In order for you to be able to reproduce this analysis, you will need to install R, Rtools and RStudio. They are very easy to install. And the best of all, they are free.

Don't be mistaken. This is high quality software that will lead you to a world full of discoveries. So, I am assuming that at least you have installed R and that you already have your RStudio screen in front of you. This is supposed to be a sort of introductory session to R, so, I am assuming that you have little or no previous experience with R either. If you are an experienced user, you will skip to the end very quick.

Remember, R has been designed by scientists for the use of scientists and engineers. It is not only a tool for discovery but for development. I showed a little bit of it with the article on the [compressibility factor](https://www.linkedin.com/pulse/building-your-own-petroleum-engineering-library-r-humble-reyes).



## The Raw Data

We will start by reading the raw data. Raw data is data as-is. It hasn't been cleaned up or checked or organized. Although this raw data has had some treatment to allow us focus on the main goal. You will have access to the raw data via GitHub. I will publish all the material there: raw data, datasets, scripts, notebooks, etc. I may even publish a R package to make the installation much easier for you.

The raw is about input data for 100 wells. The input data is the minimum required to create a well model under any nodal analysis software. The well data could be grouped as: general data (well name, field, platform), well type data (fluid, completion type, artificial lift method), PVT data, IPR data, VLP data, geothermal data, gas lift data (for those wells that have artificial lift), and well test data.

**General data**

```{r, out.width = "500px", echo=FALSE}
knitr::include_graphics("https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAyfAAAAJDk5ZWYxMjRmLTA1NzctNDZmNy05YmMzLWI4MzMwMTA3NGFiMQ.jpg")
```

**Well type data**

```{r, out.width = "500px", echo=FALSE}
knitr::include_graphics("https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAA2qAAAAJDkxN2Y5OTA3LWJiNWQtNDE3Yy04NTgxLTBlYjhhNGZkMzNkZA.jpg")
```

**PVT data:**

```{r, out.width = "600px", echo=FALSE}
knitr::include_graphics("https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAo-AAAAJDgxZmIyOTVhLTU0OTgtNGIzNy04Y2JlLTJjODJhOWU3ZDcxYQ.jpg")
```

** IPR data: **

```{r, out.width = "500px", echo=FALSE}
knitr::include_graphics("https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAqNAAAAJDljYjEyM2IxLWVhYzgtNDYyMi04ZmYyLWQ4MjIxNmNkMWQ0ZQ.jpg")
```


**Well test data:**

```{r, out.width = "800px", echo=FALSE}
knitr::include_graphics("https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAmwAAAAJDkyNjVmZWE1LWI1MzYtNGM4OC04NWNjLWY1YWY0OTUxNjdiYg.jpg")
```

The well test data transformation into tidy data will be a major task but that's life. That's how raw data comes. And then we use tools like R for the data munging. It will be fun.


## Reading the raw data

Now, back to our RStudio screen. R can read virtually any data format out there. If you just installed R and haven't installed anything else what you have is r-base. You can do a lot of stuff with it. But you wouldn't able to read an Excel spreadsheet. You have to install a package for that. The packages are supplements to the base R. If you need some specific type of plot or a statistical distribution that you didn't find in r-base you just install the package. There are 11,000+ of them. They can also be installed directly from the internet. We will start by installing the package xlsx which will allow us to read Excel .xlsx files.


```{r eval=FALSE}
install.packages("xlsx")
```

Once the package is installed we proceed to read the raw data:


```{r}
# load the library xlsx
library(xlsx)

# read the raw data
myXl <- read.xlsx("./inst/extdata/oilfield_100w_raw_data.xlsx", 
                  sheetIndex = 1, stringsAsFactors=FALSE)
```

I placed the raw data file under the directory ./inst/extdata, that why the long path. In R packages is very usual to place the raw data under this folder.

The first part of the command we see myXl, which is an object that will be holding whatever the data is inside the file. read.xlsx is the function that reads the Excel file. Then comes the long string "./inst/extdata/oilfield_100w_raw_data.xlsx", then a comma and a number "1" that means the sheet number.

After you run this command take a look the top right side of your screen. Specifically, the Environment tab. You will see that the object myXl is showing this:

```{r, out.width = "500px", echo=FALSE}
knitr::include_graphics("https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAxtAAAAJGE3NGVmZDQ5LWY4ZDYtNDExNy04YzE3LTFmMDk0YmZjMTcxNQ.jpg")
```


That means 100 **observations** or rows and 61 **variables** or columns. The raw data is already living in R. That is how rows and columns are called in data science jargon: observations and variables. Remember that because you will be seeing it a lot.

Now, if you double-click on the myXL object R automatically will open a data viewer for you.

```{r, out.width = "600px", echo=FALSE}
knitr::include_graphics("https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAuBAAAAJGRjZWM4OWNiLWY1NDMtNDZhMS04OWE3LWY1ZjZiYWM3ZjI3MA.jpg")
```


You can get the raw data file `oilfield_100w_raw_data.xlsx` via [GitHub](https://github.com/f0nzie/rNodal.oilwells/blob/master/inst/extdata/oilfield_100w_raw_data.xlsx). Download the file and start practicing opening the file and loading it in R.


## The notebook is your friend

Another thing that you will notice in this lecture is that we can combine text, math, equations and results in the same document. As a matter of fact, I am writing all of this in a R Markdown document or notebook. You can see it as the README of the package in GitHub here. It is the file README.md in green highlight.

```{r, out.width = "600px", echo=FALSE}
knitr::include_graphics("https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAvDAAAAJGMwYzIyODg4LTRkOTMtNDgyOS1hYjk1LTUwMjczNjc1OGI0OA.jpg")
```

Writing project or analysis documentation this way is not only useful but a time saver. You don't need to type your text in Word, for instance, and copy-paste the calculations or plots in the document afterwards. And most important of all, you reduce the chance of errors. You will see for yourself later when we mix calculations inside and together with the text.

## Some well data anatomy




## Some data introspection

```{r rows.print=25}
print(myXl)
```


Let's use some R functions to find out more about our data.

```{r}
# get the dimensions of the table.
dim(myXl)
```

```{r}
names(myXl)
```


Our table has `r dim(myXl)[1]` rows and `r dim(myXl)[2]` columns.

```{r}
# A summary of all the variables.
# Notice the difference between numerical and non-numerical variables
summary(myXl)
```

```{r}
# show the data type structure of the table
str(myXl)
```

```{r}
# outr table is one of R data structures along with vectors, matrices, arrays and lists.
class(myXl)
```

## Misstyped data

```{r}
unique(myXl$Wellname)
```

## Pattern detection
```{r rows.print=15}
# using a template to find out which well names do not follow a pattern
myXl[!grepl("PSCO-[M,O,P,,Q,R,S][0-9][0-9][0-9]-[T,L,S]S", myXl$Wellname),]
```

The result is that we get the observations (rows) that have incorrect well names. They are 11 instances.
This is much better than visually inspecting them in a spreadsheet, isn't it?

What are the type of offences?

* Incorrect well number: PSCO-M0007-TS, PSCO-M0026-TS
* Platform omitted: PSCO-027-TS
* Platform in lowercase: PSCO-r015-LS, PSCO-m016-LS
* Incorrect field name: PiSCO-R009-SS, PISCO-R027-LS
* Incorrect completion type: PSCO-R022-T, PSCO-Q019-L, PSCO-Q001-S
* Extra spaces in the name: PSCO-S019 -LS


## Fix the well name

Some can be fixed manually and other can be done automatically with a script.
In our particular case we only have 100 wells but what about if we have 1000, or 5000? Doin,g it manually is not an option. Some are quickyly fixable some others are more challenging. Let's start by the easier ones.

Always go from the more general to the more particular.

```{r}
# lowercase to uppercase
  myXl$Wellname <- toupper(myXl$Wellname)

# show the wells with issues
  myXl[!grepl("PSCO-[M,O,P,,Q,R,S][0-9][0-9][0-9]-[T,L,S]S", myXl$Wellname),]
```


```{r}
# removing spaces
  myXl$Wellname <- gsub(" ", "", myXl$Wellname)

# show the wells with issues
  myXl[!grepl("PSCO-[M,O,P,,Q,R,S][0-9][0-9][0-9]-[T,L,S]S", myXl$Wellname),]
```


```{r}
# complete the completion type
# We have three completion type: SS, LS and TS

  myXl$Wellname <- gsub("-L$", "-LS", myXl$Wellname)    # the dollar sign at the end, means that 
  myXl$Wellname <- gsub("-S$", "-SS", myXl$Wellname)    # we are checking at the end of the string
  myXl$Wellname <- gsub("-T$", "-TS", myXl$Wellname)

# show the wells with issues
  myXl[!grepl("PSCO-[M,O,P,,Q,R,S][0-9][0-9][0-9]-[T,L,S]S", myXl$Wellname),]

```

Those were the easy ones. There are 5 more to go.

```{r}
# detect well names that are not named as PSCO-
  myXl[!grepl("^PSCO-", myXl$Wellname), ]        # the ^ character means look at the start of the string
```

### 

```{r}
# replace any characters before the first dash
  x <- myXl$Wellname

  pattern <- "^[^-]+"
  repl_with <- "PSCO"

  myXl$Wellname <- gsub(pattern, repl_with, x, perl = TRUE)

  # show the wells with issues
  myXl[!grepl("PSCO-[M,O,P,,Q,R,S][0-9][0-9][0-9]-[T,L,S]S", myXl$Wellname),]
```

Alright. We corrected the field name in the well name. 
There are still three more wells to go which problems are:

    PSCO-M0007-TS  long well number. It should be maximum of 3 digits
    PSCO-027-TS    missing platform number
    PSCO-M0026-TS  long well number. It should be maximum of 3 digits


### correcting longer well number (digits)

```{r}
# find wells with longer well number
x <- myXl$Wellname
myXl[grepl("[0-9]{4}-", x, perl=TRUE), ]     # 
```


```{r}
library(stringr)
x <- myXl$Wellname

allIndices <- 1:length(x)
incorrectIndices <- grep("[0-9]{4}-", x, perl=TRUE)
incorrectIndices

xt <- strsplit(x[incorrectIndices], "-")
fn <- unlist(lapply(xt, "[", 1))
xl <- unlist(lapply(xt, "[", 2))
ct <- unlist(lapply(xt, "[", 3))


first <- str_sub(xl, 1, 1)                 # extract the 1st character
xu <- unlist(str_extract_all(xl, "\\d+"))  # extract the numeric part only
xn <- as.numeric(xu) / 1000 * 1000
xp <- str_pad(xn, pad = "0", width = 3)
wn <- paste0(first, xp)
corrected <- paste(fn, wn, ct, sep = "-")

myXl$Wellname[incorrectIndices] <- corrected

  # show the wells with issues
  myXl[!grepl("PSCO-[M,O,P,,Q,R,S][0-9][0-9][0-9]-[T,L,S]S", myXl$Wellname),]

```

### correct the platform in the well name

```{r}
x <- myXl$Wellname
# pick up the well index
incorrectIndices <- !grepl("PSCO-[M,O,P,,Q,R,S][0-9][0-9][0-9]-[T,L,S]S", x)
# incorrectIndices

xt <- strsplit(x[incorrectIndices], "-")

fn <- unlist(lapply(xt, "[", 1))
xl <- unlist(lapply(xt, "[", 2))
ct <- unlist(lapply(xt, "[", 3))

xl 
platform <- myXl$Platform[incorrectIndices]

wn <- paste0(platform, xl)

corrected <- paste(fn, wn, ct, sep = "-")
corrected

myXl$Wellname[incorrectIndices] <- corrected

myXl[!grepl("PSCO-[M,O,P,,Q,R,S][0-9][0-9][0-9]-[T,L,S]S", myXl$Wellname),]

# finished the corrections of the well name
```



### Company

```{r}
myXl[!grepl("Oil Gains Co.", myXl$Company),]
# We don't get any return. All the company names are the same. Cool!
```

### Analyst

```{r}
summary(myXl$Analyst)
unique(myXl$Analyst)

```

```{r}
operators <- c("Aida", "Americo", "Andrew", "Camden", "Ibironke", "Kai", "Norman", 
               "Rodrigo", "Sam", "Tom", "Vivek")

# incorrect assignements
tocorrectIndices <- which(!myXl$Analyst %in% operators)
myXl[tocorrectIndices, ]
```

We can correct manually:

```{r}
myXl$Analyst[9] <- "Ibironke"
myXl$Analyst[c(31,32,32,33)] = "Rodrigo"
myXl$Analyst[c(78,83)] = "Andrew"
myXl$Analyst[c(37)] = "Tom"

# verify if we have incorrect assignements
  tocorrectIndices <- which(!myXl$Analyst %in% operators)
  myXl[tocorrectIndices, ]

```

There is only one observation left, the one with NA.
We will have to cross-reference it.
Let's find out who are the platform operators.

### Who is the platform operator?
In our particular case, who is the platform operator in "S"?
```{r}
# Who is the platform operator?
  table(myXl$Analyst, myXl$Platform)
```

For platform S, it could be Andrew or Camden.

```{r}
myXl[myXl$Analyst %in% c("Andrew", "Camden"), ]
```

There is not a real pattern here. We will assign the well to Andrew, make a note. Then we make a call to confirm.

```{r}
myXl$Analyst[c(98)] = "Andrew"

# verify if we have incorrect assignements
  tocorrectIndices <- which(!myXl$Analyst %in% operators)
  myXl[tocorrectIndices, ]

  # Analyst is complete  
```

## Check the field

```{r}
unique(myXl$Field)
# we have two additional keywords for the field that have to be corrected.
# let's find out what indices they have
```

```{r}
# verify for bad names in field
grep("[^PISCO]", myXl$Field)      # which means those which are not named like PISCO
```

```{r}
# which row index has NAs in it
myXl[which(is.na(myXl$Field)), ]
```


```{r}
# make the correction
myXl$Field[c(7,12,27)] <- "PISCO"

# verify for bad names in field
  grep("[^PISCO]", myXl$Field)    # which means those which are not named like PISCO
  
# which row index has NAs in it
myXl[which(is.na(myXl$Field)), ]  
  
# it has been fixed now  
```



## Add a column for the Completion Type
To close this chapter, let's add a c new variable (column) where we have only the Completion Type.
We can take advantage that the last two characters of the well name is the completion type.

    nchar(): number of character of the string

```{r}
substr(myXl$Wellname, nchar(myXl$Wellname)-1, nchar(myXl$Wellname))
```


```{r}
# assign the completion type to a new column
myXl$Completion <- substr(myXl$Wellname, nchar(myXl$Wellname)-1, nchar(myXl$Wellname))

```


## Location
```{r}
myXl$Location
```

```{r}
# we can test it by not following pattern or those which are NA
pattern <- "[MQRS][0-9]{3}"

# test that Location follows the pattern
grep(pattern, myXl$Location, invert = TRUE)
# there is one non-compliant index 
# which matches what we see above
```

```{r}
myXl$Location <- substr(myXl$Wellname[19], nchar(myXl$Wellname[19])-6, nchar(myXl$Wellname[19])-3)
```


```{r}
# test that Location follows the pattern
grep(pattern, myXl$Location, invert = TRUE)
# we are done here
```


## Platform

```{r}
# verify which indices do not comply for platform
grep("[MQRS]", myXl$Platform, invert = TRUE)
# only two not following
# since the well name is already corrected, let's use it
```

```{r}
myXl$Platform <- substr(myXl$Wellname, nchar(myXl$Wellname)-6, nchar(myXl$Wellname)-6)

# verify which indices do not comply for platform
grep("[MQRS]", myXl$Platform, invert = TRUE)
# we are done here
```






```{r}
# load the library xlsx
library(xlsx)

# read the raw data
myXl <- read.xlsx("./inst/extdata/oilfield_100w_raw_data.xlsx", 1)

# lowercase to uppercase
  myXl$Wellname <- toupper(myXl$Wellname)



# removing spaces
  myXl$Wellname <- gsub(" ", "", myXl$Wellname)

  
  

# complete the completion type
# We have three completion type: SS, LS and TS

  myXl$Wellname <- gsub("-L$", "-LS", myXl$Wellname)    # the dollar sign at the end, means that 
  myXl$Wellname <- gsub("-S$", "-SS", myXl$Wellname)    # we are checking at the end of the string
  myXl$Wellname <- gsub("-T$", "-TS", myXl$Wellname)

# show the wells with issues
  myXl[!grepl("PSCO-[M,O,P,,Q,R,S][0-9][0-9][0-9]-[T,L,S]S", myXl$Wellname),]
```


```{r}
# remove non compliant field names
  # myXl$Wellname <- gsub("(^[PSCO])", "PSCO", myXl$Wellname)

# show the wells with issues
  myXl[!grepl("PSCO-[M,O,P,,Q,R,S][0-9][0-9][0-9]-[T,L,S]S", myXl$Wellname),]
```



```{r}
# test
test <- c("PiSCO", "pISCO", "PSCO")

gsub("^(PSCO)", "PSCO", test)

```



```{r}
# show wells that do have incorrect field name
myXl[!grepl("^PSCO-", myXl$Wellname), ]
```

```{r}
# same but saving the data frame
df <- myXl
pattern <- "^(?!PSCO)"
myXl[grepl(pattern, myXl$Wellname, perl = TRUE), ]
```


```{r}
# attempt to replace PISCO. nOT WORKING
df <- myXl
pattern <- "(?!PSCO+)"
df$Wellname <- gsub(pattern, "\\1", df$Wellname, perl = TRUE)

df[!grepl("PSCO-[M,O,P,,Q,R,S][0-9][0-9][0-9]-[T,L,S]S", df$Wellname),]
```


```{r}
# show wellls that do not comply with well naming pattern
df[!grepl("PSCO-[M,O,P,Q,R,S][0-9][0-9][0-9]-[T,L,S]S", df$Wellname),]
```

